### Web. HTTPS, HTTP

쉽게 설명하면 HTTPS 는 HTTP 에 암호화가 추가된 프로토콜이다.

<br>



### HTTP 와 HTTPS 의 차이점

HTTPS 는 HTTP 프로토콜에 암호화와 인증, 완전성 보호를 더한 프로토콜이다.

HTTPS 는 HTTP 통신하는 소켓 부분을 SSL, TLS 프로토콜로 대체했다.

HTTP 는 TCP와 직접 통신하지만, HTTPS 는 SSL 과 통신한다. 이 SSL이 TCP와 통신한다.

즉, HTTPS 는 SSL 의 껍질을 덮어 쓴 HTTP다. 

<br>



### HTTPS 란?

HTTPS 는 SSL 의 껍질을 덮어쓴 HTTP다. 즉, 새로운 애플리케이션 계층의 프로토콜은 아니다.

HTTPS 는 HTTP 에 암호화와 인증, 완전성 보호를 더한 프로토콜이다.

<br>



조금 더 자세히 설명해보면 아래와 같다.

- HTTP 통신하는 소켓 부분을 SSL(Secure Socket Layer), TLS(Transport Layer Security) 프로토콜로 대체한 프로토콜 

<br>



HTTP 는 원래 TCP와 직접 통신하지만, HTTPS 는 SSL과 통신한다. 이 SSL 이 TCP와 통신한다. 

HTTPS에서는 SSL 통신시 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다. 공통키를 공개키 암호화 방식으로 교환한 후 다음부터의 통신은 공통키 암호를 사용하는 방식이다.

<br>



### 모든 웹 페이지에서 HTTPS를 사용하지 않는 이유

평문 통신에 비해 암호화 통신은 CPU, 메모리 등 리소스가 많이 필요하다. 통신할 때 마다 암호화를 하면 리소스를 소비하게 되는데, 서버 한 대 당 처리할 수 있는 리퀘스트의 수가 줄어들게 된다. 이런 이유로 민감한 정보를 다를 때에만 HTTPS 에 의한 암호화 통신을 사용한다.

<br>



### SSL 인증서는 어떻게 작동하나요?

SSL 인증서는 "SSL 핸드쉐이크" 과정을 통해 웹사이트/서버와 브라우저간 암호화된 연결을 수립한다. 

<br>



인증

- 사용자가 웹사이트에서 시작하는 모든 신규 세션에 대해 브라우저와 서버는 각각 다른 SSL 인증서를 교환하고 검증한다.

암호화

- 서버는 브라우저와 공개키를 공유하고 <u>브라우저는 이 키를 사용해 프리마스터 키를 생성, 암호화</u>한다.
- 이것을 키 교환이라고 한다.

복호화

- 개인키를 사용해 프리마스터 키를 복호화하고 세션 기간 동안 사용되는 암호화된 보안 연결을 수립한다.



 <br>



#### HTTPS에 대해서 설명하고 SSL Handshake 에 대해서 설명해보세요.

 SSL Handshake란 송신자와 수신자가 암호화된 데이터를 교환하기 위한 일련의 협상과정을 뜻합니다. 



![](https://velog.velcdn.com/images%2Fapolontes%2Fpost%2Fe0e131ee-031b-4093-b2d1-b6dae81e3a2e%2F2022-02-22_23-44-05.png)

<br>



1\) 브라우저 → 서버 : Client Hello

아래 정보를 서버에 전달

- 브라우저의 SSL, TLS 버전 정보
- 브라우저가 사용하는 암호화 방식
- 브라우저가 생성한 난수
- etc

  ↓

2\) 서버 → 브라우저 : Server Hello

서버는 아래의 정보를 클라이언트에 전달

- 서버의 공개키가 담긴 SSL 인증서
- 서버가 생성한 난수
- etc

  ↓

3\) 브라우저 : Server 인증서 확인

- CA 리스트, CA 공개키, 서버 인증서 확인
- Parameter Secret 생성 (브라우저 난수, 서버 난수)

  ↓

4\) 서버 → 브라우저 : Parameter Secret 전달

  ↓

5\) 서버 : Parameter Secret 복호화

- Parameter Secret 복호화
- Master Secret 생성 : Parameter Secret 을 사용해서 생성
- Session Key 생성 : Master Secret 을 사용해서 생성

  ↓

6\) SSL Handshake 종료 & HTTPS 통신 시작

- SSL 연결 수립

<br>



### HTTP 프로토콜

#### HTTP 프로토콜의 특징

- Connectionless
  - 비연결형 통신이다. 연결을 유지하지 않는다.
  - 커넥션을 계속 유지하는 것으로 인한 리소스 소비가 적다.
- Stateless
  - 서버가 클라이언트의 상태정보를 저장하지 않는다.
  - 클라이언트의 이전 요청과 현재 요청을 구분하지 않는다. 각각의 통신이 독립적이다.
  - Stateless 는 정보 공유가 최소화되어 비용을 절감되면서 서버 확장이 가능하다.

<br>



#### HTTP 1.1 VS 2.0 VS 3.0

 - HTTP 1.1   
   - 기본적으로 **Connection당 하나의 요청을 처리하도록 설계**되어 있습니다. 따라서 동시 전송 문제와 다수의 리소스를 처리하는 데 속도 및 성능 이슈가 있습니다. 
   - 하나의 응답이 지연되면 다음 요청은 무한대기 상태가 되는 특정 응답지연(HOL)- **요청별로 Connection을 만들므로 3-Way handshake가 반복적으로 일어나** 불필요한 **Round Trip Time 증가**
   - 매 요청시마다 중복된 헤더값을 전송하면서 생기는 헤비한 Header구조 등의 문제가 있습니다.   
 - HTTP 2.0              
   -  1.1의 문제를 해결하기 위해 등장했습니다.
   -  **한 커넥션에 여러개의 메시지를 동시에 주고받을 수 잇습니다.**
   -  요청 리소스 간의 의존관계(우선순위) 설정이 가능합니다.
   -  헤더 정보를 HPACK 압축 방식을 사용해 전송할 수 있습니다. 
   -  응답속도가 15~50% 정도 향상됩니다.
 - HTTP 3.0     
   - HTTP 프로토콜의 세번쨰 메이저 버전으로, TCP를 사용하는 기존 1.1 이나 2.0과는 달리 **UDP 기반**의 QUIC를 사용합니다.
   - RTT감소로 지연시간이 단축됩니다.
   - 패킷 손실 감지에 걸리는 시간이 단축됩니다.
   - 멀티 플렉싱을 지원합니다.
   - 클라이언트의 IP가 바뀌어도 연결이 유지됩니다.





#### HTTP 응답코드

> 참고 : [HTTP 상태코드 (100, 200, 300, 400, 500) 정리](https://pingfanzhilu.tistory.com/entry/HTTP-HTTP-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C100-200-300-400-500-%EC%A0%95%EB%A6%AC)



1XX (Informational: 조건부 응답): **요청을 받고, 프로세스는 진행**중

- 100 (CONTINUE) 
  - 상태가 괜찮음, 클라이언트가 계속해서 요청하거나 요청이 완료된 경우에 무시하라는 코드

- 101 (SWITCHING\_PROTOCOL) 
  - 클라이언트가 보낸 upgrade 요청 헤더에 대한 응답. 서버에서 프로토콜을 변경할 것임을 알려주는 것


<br>



2XX (Success: 성공): **요청을 성공**적으로 받고 인식되어 수행됨

- 200 (OK) 
  - "요청이 성공적으로 완료되었다"는 의미

- 201 (CREATED) 
  - "요청이 성공적이었다" + "새로운 리소스가 생성되었다" 는 의미

- 202 (ACCEPTED)
  - "요청을 수신했지만 그에 응하여 행동할 수 없다는 의미"


<br>



3XX (Redirection: 리다이렉션): 요청 완료를 위해 추가 작업 필요. (e.g. **리다이렉션**)

- 300 (MULTIPLE\_CHOICE)
  - 요청에 대해 하나 이상의 응답이 가능하다는 의미

- 301 (MOVED\_PERMANENTLY)
  - 요청한 리소스의 URI 가 변경되었다는 의미

- 302 (FOUND)
  - 요청한 리소스의 URI 가 일시적으로 변경되었다는 의미

- 303 (SEE\_OTHER) : "다른 곳을 보세요!!"
  - 클라이언트가 요청한 리소스를 다른 URI 에서 GET요청을 통해 얻어야 할 경우 서버가 클라이언트로 직접 보내는 응답


<br>



4XX (Client error: 클라이언트 에러): 요청 문법이 잘못되었거나 요청을 처리할 수 없는 상태

- 400 (BAD\_REQUEST) 
  - 잘못된 문법으로 인해 서버가 요청을 이해할 수 없다는 의미

- 401 (UNAUTHORIZED)
  - 인증되지 않았다는 의미
- 403 (FORBIDDEN)
  - 클라이언트가 컨텐츠에 접근할 권리를 가지고 있지 않다는 의미
- 404 (NOT\_FOUND)
  - 요청 받은 리소스를 서버가 찾을 수 없다는 의미

<br>



5XX (Server Error: 서버 오류): **명백히 유효한 요청에 대해 서버 충족 실패**

- [추가 참조](https://velog.io/@jennyfromdeblock/Http-%EC%9D%91%EB%8B%B5%EC%BD%94%EB%93%9C-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0)

- 500 (INTERNAL\_SERVER\_ERROR)
  - 처리할 수 없는 내부 오류가 발생했다.
- 501 (NOT\_IMPLEMENTED)
  - 요청 메서드는 서버가 지원하지 않거나 처리할 수 없다는 의미
- 503 (SERVICE\_UNAVAILABLE)
  - 서버가 요청을 처리할 준비가 되지 않았다는 의미

<br>



#### HTTP Method - PUT과 PATCH의 차이


둘다 리소스를 업데이트 한다는 점에서는 같지만, PUT은 리소스의 모든 것을 업데이트하는 반면, PATCH는 일부만을 업데이트한다는 차이가 있습니다.







