### Spring Framework 일반적인 질문들

### 대용량 트래픽에서 장애가 발생하면 어떻게 대응할 것인가요?

스케일 업, 스케일 아웃. 이렇게 두가지 방법을 생각할 것 같습니다.

스케일 업은 하드웨어 스펙을 올려서 대응하는 방식이고

스케일 아웃은 서버를 여러 대 추가해서 시스템의 처리량을 증가시키는 방식입니다.

<br>



### WAS(Web Application Server) 와 WS(Web Server) 의 차이점

WAS (Web Application Server)

- 비즈니스 로직을 넣을 수 있다.
- Tomcat, PHP, ASP, .NET 등등

<br>



WS (Web Server)

- 비즈니스 로직을 넣을 수 없다.
- e.g. Nginx, Apache 

<br>



### Spring Boot, Spring Framework 의 차이점

Spring Boot 는 Auto Configuration 을 제공해준다. <br>

Spring Framework 를 사용하면 초기 프로젝트 셋업시 많은 설정들을 직접 해줘야 한다.<br>

Spring Boot 를 사용할 경우 설정의 많은 부분들을 자동화하기에, 초기 환경설정에 많은 작업을 하지 않아도 된다.<br>

`spring-boot-starter` 라는 접두사가 붙은 의존성들을 추가해주면 설정이 간단하게 완료된다. 이 `spring-boot-starter` 로 시작하는 접두사는 스프링 개발 팀에서 공식으로 지원하기 시작되면 제공되는 라이브러리다.<br>

내장된 톰캣을 사용해 서버를 바로 실행할 수 있다.<br>

<br>

e.g. spring-boot-starter-data-jpa<br>

<br>



### Spring Framework 의 장점

> 경량화프레임워크, IoC, DI, AOP

<br>



경량화된 프레임워크

- 객체의 생성, 소멸 등 객체의 라이프 사이클을 관리할 수 있다.
- 스프링 프레임워크로부터 필요한 객체를 얻어와서 사용할 수 있다.

<br>



제어의 역전(IoC)

- 제어의 역전(IoC)를 통한 애플리케이션의 느슨한 결합을 도모

- 컨트롤의 제어권이 사용자가 아닌 프레임워크에 있다.
- 필요에 따라 스프링에서 사용자의 코드를 호출한다.

<br>



의존성 주입(DI)

- 각 객체간 필요한 의존성이 있을 경우 스프링 프레임워크의 컨테이너에 의해 관리되는 객체일 경우 스프링 컨테이너가 직접 객체를 주입해준다.

<br>



관점지향 프로그래밍 (AOP, Aspect Oriented Programming)

- 트랜잭션, 로깅, 보안 등 공통적으로 사용될 수 있는 기능의 경우 기능을 분리해 관점(Aspect)이라는 기준으로 묶어서 관리할 수 있다.

<br>



### IoC (제어의 역전) 이란?

객체의 생성/소멸 등과 같은 라이프사이클 등을 프로그래머가 직접 기술하는 것이 프레임워크에 의해 관리/제어 되도록 하는 것을 제어의 역전이라고 부른다.<br>

스프링은 IoC 컨테이너에 객체들을 생성하면 객체끼리의 의존성을 주입(DI, Dependency Injection) 하는 역할을 수행한다.<br>

컨테이너에 등록한 객체들은 빈(Bean) 이라고 부른다.<br>

<br>



### DI (의존성 주입, Dependency Injection) 이란?

필요한 객체를 프로그래머가 직접 생성하는 것이 아니라 외부로부터 주입받는 것을 의존성 주입이라고 한다.<br>

이렇게 의존성을 외부에서 주입받아서 의존성을 해결하면 객체간의 결합도를 줄일수 있고 코드의 재사용성 역시 좋아진다.<br>

<br>



의존성 주입을 하는 방법은 3가지의 방법이 있다.<br>

- 생성자 주입
- 필드 주입
- Setter 주입

<br>



이 중에서 스프링에서 권장하는 의존성 주입 방법은 생성자 주입 방식이다.<br>

생성자 주입을 권장하는 주요 이유는 아래와 같다.<br>

- 순환참조 방지
- 불변성을 가짐
- 테스트에 용이하기 때문

<br>



### 필드 주입 vs 생성자 주입 (순환참조 발견이 쉽다는 장점)

만약 아래와 같이 필드 주입을 하는 경우를 보자. 이렇게 의존성 주입을 필드 주입으로 작성하면 컴파일 타임에 IDE 레벨에서 순환 참조 문제가 있는지 파악할 방법이 없다. 따라서 <u>순환참조가 발생하는 문제가 있더라도 런타임에 아무런 오류나 경고 없이 구동된다는 단점</u>이 있다.<br>



반면, 아래의 코드들을 생성자 주입을 통해 의존성 주입 코드를 작성한 후 실행하면 런타임에 애플리케이션 구동시에 오류/경고를 발생시키며 구동이 멈춘다. 주로 `BeanCurrentlyInCreationException` 이 발생한다. 배포 전까지도 순환 의존성을 감지하지 못한채로 배포되는 불상사를 방지할 수 있다는 장점이 있다.<br>

필드 주입으로 작성했을 때에는 런타임에 아무 오류나 경고 없이 실행됐지만, 생성자 주입은 이렇게 애플리케이션 구동 시에 순환참조관련 오류가 있다는 것을 확인이 가능하다는 장점이 있다.<br>

생성자 주입은 순환참조 문제 뿐만 아니라 의존관계를 명확하게 외부로 노출시키기에 오류를 체크하기에도 좋다.

```java
@Service
public class HelloService{
    
    // 순환참조
    @Autowired
    private LogService logService;
    
    public void printHello(String msg){
        logService.log(msg);
    }
    
}
```

<br>



```java
@Service
public class LogService{
    
    // 순환참조
    @Autowired
    private HelloService helloService;
    
    public void debug(){
        helloService.printHello("LogService >>> ");
    }
}
```

<br>



### 생성자 주입의 장점

참고: [의존성 주입 3가지 방법 (생성자 주입, Field 주입, Setter 주입)](https://dev-coco.tistory.com/70)



- 순환참조 방지
  - 애플리케이션 구동시에 순환참조 에러와 함께 애플리케이션 구동이 멈추기에, 배포 전에 순환 참조 문제를 찾아서 해결이 가능하다.
  - 반면 Field 주입, Setter 주입의 경우 순환참조 문제를 미연에 찾아서 대비하기 쉽지 않다.

- 불변성 
  - 생성자에서 초기화하는 필드는 final 로 선언할 수 있다. 따라서 런타임에 의존성을 주입받는 객체가 변할일이 없게 된다.
  - 반면 field 주입, setter 주입, 메서드 주입의 경우 의존성을 가진 필드의 변경 가능성을 열어두기에 불완전한 객체가 된다는 단점이 있다.
- 테스트에 용이하다.
  - 생성자 주입을 사용하면 테스트 코드를 좀 더 편리하게 작성할 수 있다.

<br>



### 스프링 빈(Bean) 의 라이프사이클

스프링 빈의 라이프사이클은 아래와 같다.

- 스프링 IoC 컨테이너 생성
- 스프링 빈 생성
- 의존관계 주입
- 초기화 콜백 메서드 호출
- 사용
- 소멸 전 콜백 메서드 호출
- 스프링 종료

<br>



스프링은 크게 3가지의 방법으로 빈 생명주기 콜백을 관리한다.

- 인터페이스 (InitializingBean, DisposableBean)
- 설정 정보에 초기화 메서드, 종료 메서드 지정
- @PostConstruct, @PreDestroy 어노테이션 지정

<br>



### Bean 생명 주기 콜백 (다른 문서에 따로 정리해둠)

별도 문서에 따로 정리해둠.

<br>



### 스프링 빈 스코프 (Bean Scope)

#### 스프링의 싱글톤 스코프

스프링의 기본 설정이다. Bean 생성 시 다른 설정을 하지 않으면 디폴트 설정으로 싱글톤 스코프가 적용된다.<br>

즉, 스프링은 싱글톤 스코프를 기본 옵션으로 해서 빈(Bean) 들을 관리한다. 요청이 올때마다 매번 객체를 생성하지 않고 이미 만들어둔 객체를 사용한다. 따라서 객체를 효율적으로 사용하게 된다.<br>

싱글톤 스코프의 빈을 사용할 때 얻을 수 있는 장점은 아래와 같다.<br>

- static 키워드, private 생성자를 사용하지 않기에 조금 더 객체지향적인 개발을 할 수 있다.
- 테스트가 편리해진다.

<br>



#### 스프링의 프로토타입 스코프 빈

프로토타입 스코프 빈으로 지정된 빈(Bean)은 컨테이너에게 빈(Bean)을 요청할 때마다 매번 새로운 객체를 생성해서 반환한다.<br>

싱글톤 스코프를 적용한 빈(Bean)을 사용할 경우에는 이미 생성된 객체를 컨테이너가 반환해주는 반면, 프록시 스코프가 적용된 빈(Bean)을 사용할 경우에는 프로그램에서 Bean 객체를 필요할 때마다 Bean 객체를 새로 생성해서 반환해준다.<br>

프로토타입 스코프 빈(Prototype Scope Bean) 사용시 `@Scope` 어노테이션을 통해 스코프를 설정할 수 있다.<br>

<br>



e.g.

```java
@Scope("prototype")
```

<br>



### 스프링 애플리케이션의 초기화 시점 (@PostConstruct vs ApplicationReadyEvent)

애플리케이션 초기화 시점에 DB에서 데이터를 불러온 후 트랜잭셔널한 작업을 처리해야 하는 경우가 있다.

애플리케이션 초기화 시점을 이벤트로 사용하기 위해 아래의 두가지 방법 중 하나를 선택하게 된다.

<br>

- ApplicationReadyEvent
  - 스프링 컨테이너가 로딩된 시점에 호출된다.
  - <u>애플리케이션이 리퀘스트를 받을 준비가 되었을 때</u> ApplicationReadyEvent 가 발생한다.
- @PostConstruct
  - 스프링 컨테이너의 로딩이 완료된 시점이 아니라 의존성 주입이 완료된 시점에 호출된다.
  - 즉, <u>컨테이너가 모두 로딩된 상태가 아니고 의존성 주입만 완료된 시점</u>이라는 의미다.

<br>



