### Transactional. Transactional AOP와 프록시, 프록시 Bean

스프링에서 Bean 등록 시 `@Transactional` 이 붙은 클래스에 대해 프록시 객체가 생성/등록되는 원리에 대해 정리해봤다.<br>

<br>



### AOP 기반으로 동작하는 @Transactional 프록시

Spring Data 는 Spring AOP 를 통해 @Transactional 어노테이션이 붙은 타겟 메서드/클래스에 대해 트랜잭션 자원의 전처리/후처리를 수행한다.<br>

Spring Data 는 @Transactional 이 하나라도 포함된 클래스를 직접 접근해서 AOP 처리하지 않고 실제 객체를 상속(확장)한 프록시 객체를 통해 AOP 처리를 한다.<br>

<br>



### 프록시 객체란?

- `@Transactional` 이 적용된 타겟은 프록시 객체라고도 부른다.
- spring data 내에서 `@Transactional` 이 붙은 타겟을 접근할 때 직접 접근하지 않고 <u>기존 로직의 기능을 확장(상속)해서</u> 트랜잭션 자원 처리 기능을 추가한 프록시 객체를 새로 생성해서 사용한다.
- 프록시 객체는 쉽게 설명하면 가짜 객체라고 생각하면 된다.
- 이렇게 생성된 프록시 객체 내에는 트랜잭션의 시작/커밋/롤백 처리를 후처리할 수 있는 내부 로직들이 정의되어 있다.



<br>



### @Transactional 프록시의 동작, 어려워지는 점

Spring Data 는 @Transactional 이 하나라도 포함된 클래스를 직접 접근해서 AOP 처리하지 않고 실제 객체를 상속(확장)한 프록시 객체를 통해 AOP 처리를 한다.<br>

이렇게 실제 객체를 상속(확장)한 프록시 객체로 전처리/후처리를 훅 처럼 처리한다.<br>

이때 `@Transactional` 이 있는 클래스를 **프록시 객체로 메서드를 수행하는지** 또는 **부모클래스의 객체로 메서드를 실행하게 되는지**를 판단하는 것이 어렵게 된다. 이런 점이 많은 사람들이 @Transactional 을 어렵게 느끼는 이유가 된다.<br>

왜냐하면 메서드를 트랜잭셔널 프록시 객체로 실행하지 않고 일반 객체의 메서드로 실행할 경우는 트랜잭션 자원 처리에 관련된 콜백 메서드들이 적용되지 않기 때문이다.<br>



<br>





### 프록시 Bean : 프록시 객체를 빈(Bean) 등록

- 스프링 컨테이너 로딩 시 스프링 컨테이너는 @Transactional 적용 대상의 객체를 프록시 라이브러리를 이용해서 <u>실제 객체를 확장한 가짜 객체</u>를 프록시 방식으로 생성해둔다.
- 스프링 컨테이너는 이렇게 생성된 <u>프록시 객체</u>를 빈(Bean) 으로 등록한다. 
- 실제 객체를 빈(Bean) 으로 등록하는 것이 아니라 트랜잭션 기능이 확장된 프록시 객체(가짜객체)를 빈(Bean)으로 등록한다.



<br>


