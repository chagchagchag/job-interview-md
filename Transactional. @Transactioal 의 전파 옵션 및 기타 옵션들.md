### Transactional. @Transactioal 의 전파 옵션 및 기타 옵션들

### REQUIRED

가장 많이 사용하는 기본설정.<br>

기존 트랜잭션이 없으면 생성하고 있으면 참여한다.<br>

트랜잭션이 필수라는 의미로 이해하면 된다. <br>

필수이기 때문에 없으면 만들고, 있으면 참여한다. <br>

- 기존 트랜잭션 없음 : 새로운 트랜잭션을 생성한다.
- 기존 트랜잭션 있음 : 새로운 트랜잭션을 생성한다.



<br>



### REQUIRED\_NEW

항상 새로운 트랜잭션을 생성한다.

- 기존 트랜잭션 없음 : 새로운 트랜잭션을 생성한다.
- 기존 트랜잭션 있음 : 새로운 트랜잭션을 <u>생성</u>한다.
  - `REQUIRED` 를 사용할 때에는 새로운 트랜잭션에 <u>참여</u> 했음에 유의해서 보자.



<br>



### SUPPORT

트랜잭션을 지원한다는 의미다.

기존 트랜잭션이 없으면 없는 대로 진행하고 기존 트랜잭션이 있으면 참여한다.

- 기존 트랜잭션 없음 : 트랜잭션 없이 진행.
- 기존 트랜잭션 있음 : 기존 트랜잭션에 <u>참여</u>한다.



<br>



### NOT\_SUPPORT

트랜잭션을 지원하지 않는다는 의미다.

- 기존 트랜잭션 없음 : 트랜잭션 없이 진행한다.
- 기존 트랜잭션 있음 : 트랜잭션 없이 진행한다.(기존 트랜잭션은 보류한다.).



<br>



### MANDATORY

의무사항이다. 트랜잭션이 반드시 있어야 한다. 기존 트랜잭션이 없으면 예외가 발생한다.

- 기존 트랜잭션 없음 : `IllegalTransactionStateException` 예외 발생
- 기존 트랜잭션 있음 : 기존 트랜잭션에 참여한다.



<br>



### NEVER

트랜잭션을 사용하지 않는다는 의미다. 기존 트랜잭션이 있으면 예외가 발생한다. 기존 트랜잭션도 허용하지 않는 강한 부정의 의미로 이해하면 된다.

- 기존 트랜잭션 없음 : 트랜잭션 없이 진행한다.
- 기존 트랜잭션 있음 : `IllegalTransactionStateException` 예외 발생



<br>



### NESTED

중첩 트랜잭션은 외부 트랜잭션의 영향을 받지만, 중첩 트랜잭션은 외부에 영향을 주지 않는다.

- 기존 트랜잭션 없음 : 새로운 트랜잭션을 생성한다.
- 기존 트랜잭션 있음 : 중첩 트랜잭션을 생성한다.



<br>

**참고**<br>

JDBC savepoint 기능을 사용한다. DB 드라이버에서 해당 기능을 지원하는지 확인이 필요하다. 중첩 트랜잭션은 JPA에서는 사용할 수 없다.

<br>



### 트랜잭셔널 옵션들

#### value, transactionManager

트랜잭션을 사용하려면 먼저 스프링 빈에 등록된 어떤 트랜잭션 매니저를 사용할지 알아야 한다. 생각해보면 코드로 직접 트랜잭션을 사용할 때 분명 트랜잭션 매니저를 주입 받아서 사용했다.

@Transactional 에서도 트랜잭션 프록시가 사용할 트랜잭션 매니저를 지정해주어야 한다.사용할 트랜잭션 매니저를 지정할 때는 value , transactionManager 둘 중 하나에 트랜잭션 매니저의 스프링 빈의 이름을 적어주면 된다.

이 값을 생략하면 기본으로 등록된 트랜잭션 매니저를 사용하기 때문에 대부분 생략한다. 

<u>그런데 사용하는 트랜잭션 매니저가 둘 이상이라면</u> 다음과 같이 트랜잭션 매니저의 이름을 지정해서 구분하면 된다.

<br>



#### rollbackFor

예외 발생시 스프링 트랜잭션의 기본 정책은 다음과 같다.

언체크 예외인 RuntimeException, Error 와 그 하위 예외가 발생하면 롤백한다.

체크 예외인 Exception 과 그 하위 예외들은 커밋한다.

<br>



이 옵션을 사용하면 기본 정책에 추가로 어떤 예외가 발생할 때 롤백할지 지정할 수 있다.

```java
@Transactional(rollbackFor = Exception.class)
```

<br>



예를 들어서 이렇게 지정하면 체크 예외인 Exception 이 발생해도 롤백하게 된다. (하위 예외들도 대상에 포함된다.)

rollbackForClassName 도 있는데, rollbackFor 는 예외 클래스를 직접 지정하고,

rollbackForClassName 는 예외 이름을 문자로 넣으면 된다.

<br>



#### noRollbackFor

앞서 설명한 rollbackFor 와 반대이다. 기본 정책에 추가로 어떤 예외가 발생했을 때 롤백하면 안되는지를 지정할 수 있다. 예외 이름을 문자로 넣을 수 있는 `noRollbackForClassName` 도 있다. 롤백 관련 옵션에 대한 자세한 내용은 뒤에서 더 자세히 설명한다.<br>

<br>



#### propagation

트랜잭션 전파에 관련된 옵션이다. 자세한 내용은 뒤에서 설명한다.<br>

<br>



#### isolation

트랜잭션 격리 수준을 지정할 수 있다. 기본값은 데이터베이스에서 설정한 트랜잭션 격리수준을 사용하는 `DEFAULT` 이다. 대부분 데이터베이스에서 설정한 기준을 따른다. 애플리케이션 개발자가 트랜잭션 격리수준을 직접 지정하는 경우는 드물다.

- DEFAULT : 데이터베이스에서 설정한 격리수준을 따른다
- READ\_UNCOMMITTED : 커밋되지 않은 읽기
- READ\_COMMITTED : 커밋된 읽기
- REPEATABLE\_READ : 반복 가능한 읽기
- SERIALIZABLE : 직렬화 가능



<br>



참고\)

> 강의에서는 일반적으로 많이 사용하는 `READ COMMITTED` (커밋된 읽기) 트랜잭션 격리 수준을 기준으로 설명한다. 트랜잭션 격리 수준은 데이터베이스 자체에 관한 부분이어서 이 강의 내용을 넘어선다. 
>
> 트랜잭션 격리수준에 대한 더 자세한 내용은 데이터베이스 매뉴얼이나, JPA 책 16.1 트랜잭션과 락을 참고하자.

<br>



#### timeout

트랜잭션 수행 시간에 대한 타임아웃을 초 단위로 지정한다. 기본값은 트랜잭션 시스템의 타임아웃을 사용한다. 운영환경에 따라 동작하는 경우도 있고 그렇지 않은 경우도 있기 때문에 꼭 확인하고 사용해야 한다.<br>

timeoutString 도 있는데, 숫자 대신 문자 값으로 지정할 수 있다.<br>

<br>



#### label

트랜잭션 애노테이션에 있는 값을 직접 읽어서 어떤 동작을 하고 싶을 때 사용할 수 있다.<br>

<br>



#### readOnly

트랜잭션은 기본적으로 읽기,쓰기가 모두 가능한 트랜잭션이 생성된다. `readOnly=true` 옵션을 사용하면 읽기 전용 트랜잭션이 생성된다. 이 경우, 등록,수정,삭제가 안되고 읽기 기능만 작동한다. (드라이버나 데이터베이스에 따라 정상동작하지 않는 경우도 있다.)<br>

<br>



그리고 readOnly 옵션을 사용하면 읽기에서 다양한 성능 최적화가 발생할 수 있다. readOnly 옵션은 크게 3곳에서 적용된다.<br>

<br>



##### readOnly 옵션으로 성능 최적화가 발생하는 곳

- 라이브러리
- JDBC 드라이버
- 데이터베이스

<br>



###### 1\) 라이브러리

- jdbcTemplate 은 읽기 전용 트랜잭션 안에서 변경 기능을 실행하면 예외를 던진다.
- JPA (하이버네이트)는 읽기 전용 트랜잭션의 경우 커밋 시점에 플러시를 호출하지 않는다.
  - 읽기 전용이니 변경에 사용되는 플러시를 호출할 필요가 없다. 추가로 변경이 필요없으니 변경 감지를 위한 스냅샷 객체도 생성하지 않는다. 이렇게 JPA 에서는 다양한 최적화가 발생한다.

<br>



JPA 관련 내용은 JPA 를 더 학습해야 이해할 수 있으므로 지금은 이런 것이 있다 정도만 알아두자.<br>

<br>



###### 2\) JDBC 드라이버

- 참고로 여기서 설명하는 내용들은 DB와 드라이버 버전에 따라서 다르게 동작하기 때문에 사전에 확인이 필요하다.
- 읽기 전용 트랜잭션에서 변경 쿼리가 발생하면 예외를 던진다.
- 읽기, 쓰기 (마스터, 슬레이브) 데이터베이스를 구분해서 요청한다. 읽기 전용 트랜잭션의 경우 읽기(슬레이브) 데이터베이스의 커넥션을 획득해서 사용한다.



e.g.

- https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-source-replicareplication-connection.html



<br>



###### 3\) 데이터베이스

- 데이터베이스에 따라 읽기 전용 트랜잭션의 경우 읽기만 하면 되므로 내부에서 성능 최적화가 발생한다.



<br>

