### 계층별 테스트

각각의 기능의 경계를 명확하게 해두면 테스트 코드가 배포 전 동작 검증을 위한 하나의 수단이 될 수 있어서 좋다.<br>

가장 변경이 많이 되는 계층 → 변경사항이 다소 고정된 계층 순으로 계층을 나열해보면 아래와 같다.

- Controller → Service → Repository, DAO

<br>



### Controller

Controller 는 기획적인 면에서 OOORequest, OOOResponse 의 필드들이 변할 수 있어야 한다. 사업적인 면에 의해, 화면의 기획에 의해 가장 자주 많이 변경되는 곳이다. App, Web 과 맞닿아있는 endpoint 이기에 Swagger 나 RestDocs 같은 API 문서에 정의해둔 API 명세대로 Request, Response 가 이루어짐을 보장할 수 있는 테스트를 작성하는 것이 좋다. 예를 들면 아래의 테스트 코드들이 작성될 수 있다.

- 파라미터 바인딩, 파라미터 밸리데이션이 정확히 수행되는지를 보장하는 테스트 코드
- Exception 발생 시 미리 정해둔 각 Exception 에 대해 발생하는 예외코드, 예외메시지가 일치하는지를 보장하는 테스트 코드
- 특정 예외 발생시 Response Code가 올바르게 Response 로 전달되는지를 보장하는 테스트 코드



Controller 계층에서는 가급적 Service 계층의 비즈니스 논리보다는 예외코드, 파라미터 바인딩, 파라미터 밸리데이션, Response Code 에 관련된 코드 들만을 작성하는 것이 좋다. 그래야 Service 계층이 변경되어도 Controller 까지 변경해서 내부 로직의 flow 를 일일이 머릿속에 기억하고 있어야 하는 피곤함이 줄어든다.







아래에서부터는 다시 정리 예정... 휴..



### Service





### Repository, DAO

데이터를 Join 등을 통해 조회하고, 삽입/삭제/수정을 원자적으로 수행할수 있어야 하고, 자주 변경될 여지가 가급적 적어야 하는 계층이다.<br>

Repository, DAO 의 쿼리 문에 자주 변경되는 코드를 작성하면 안된다. 가급적 자주 변경되는 내용은 Controller, Service 에서 비즈니스로직이나, Request, Response 모델로 명확하게 표현되야 한다. 예를 들어 Repository 에서는 가급적이면 Select Case 문을 통한 데이터 가공은 지양해야 한다. <br>

가끔은 Subquery 가 안티패턴이라는 이야기도 있지만, 필요하다면 써도 된다. 다만, 그 조회 연산이 추후 변경 가능성이 없고 확정된 기능이면 그대로 사용해도 될 것 같다.<br>

1년 전 쯤는 DAO 쪽 로직을 다루는 작업이 항상 "회사 제품"의 데이터를 다루는 것이라고 생각하고 신중하게 접근해야 한다고 생각했었는데, 지금 보면 조금 쑥스러운 생각인것 같기도 하다.

DB 계층의 테스트를 할 때는 아래의 테스트 코드들을 작성했던것 같다. 

- 



---

↓

↓

↓

지울 예정







### Controller

> **참고\) 테스트 코드 작성 전 Controller 는 이렇게 작성되면 좋다.**<br>
>
> Controller 에서 비즈니스 로직을 수행하면 안된다. Controller 에서는 주어진 Request 에 대해 Service 가 어떤 결과를 내면 어떤 응답을 낼지, 파라미터의 값이 부정확하면 어떤 파라미터에 대해 어떤 예외를 낼지, 어떤 요청은 어디로 포워딩할지 등을 적는 편이다. 경험상 레거시가 심한 코드도 봤고, Controller 를 깔끔하게 구성한 코드도 봤다. Controller 계층을 깔끔하게 작성한 코드는 대부분 Controller 에서 비즈니스 로직 대신 Validation 을 명확하게 수행했었다.

- 파라미터 바인딩, 밸리데이션
  - e.g. password 는 알파벳 소문자, 대문자를 구별하며, 숫자는 두 글자 포함되어야 하고 특수문자를 한 글자 이상 포함해야 한다.
  - e.g. 상품 코드는 null 일 수 없다.
- 파라미터 바인딩, 벨리데이션이 틀릴 경우 예외가 적정한지를 테스트
  - e.g. page 번호가 음수일 경우 IllegalPageNumberException 을 낸다.
- Service 계층의 예외를 가정했을 때 RestControllerAdvice 를 통해 올바른 예외를 내는지를 가정
- 계속해서 추가



안좋은 테스트의 예

- Service, DAO 등에 어떤 파라미터가 조합이 되어 넘겨져야 원하는 Controller 로 원하는 결과가 오는지를 가정한 테스트는 DB, Service 계층에 종속성을 가지게 되므로 Service, DAO가 변경되면 Controller 가 변경되게 된다.

- 계속해서 추가

<br>



### Service

> **참고\) 테스트 코드 작성 전 Service 는 이렇게 작성되면 좋다.**<br>
>
> @Autowired 는 가급적 지양된 코드가 테스트에 용이하다. 
>
> 각각의 기능을 메서드 단위로 구분하고, 하나의 메서드가 여러 역할을 수행하지 않도록 구성한다.
>
> 공통된 내용은 추상화하고, 추상화 기반으로 다양해지는 것은 다형성으로 풀어낸다.
>
> 뭐지? 방금 뭐가 떠올랐다가 사라졌는데? 왜 기억이 안나지? 칼슘을 더 먹어야 하나??

<br>

- Repository 에 데이터를 저장할 때 트랜잭션 상에 예외가 있을 경우에 대한 처리
- 트랜잭션 처리 결과 테스트 코드
- 주요 체크 로직 테스트
- 세부적인 비즈니스 로직 테스트 코드
  - e.g. 회원 가입 시도 시 request history log 추가 
  - e.g. 주문 시도 시 주문 Requset history log 추가
  - e.g. ... 계속 추가
- 생성자 주입이 잘 지켜진다면 Spring 의 @MockBean 으로 주입 받을 경우도 있고 순수 Java 를 이용해 객체를 생성해 테스트를 해도 자유롭게 편리하게 테스트가 가능해진다.

<br>



### Repository, DAO, Mybatis, etc

> **참고\)테스트 코드 작성 전 Repository, DAO, Mybatis 는 이렇게 작성되면 좋다.**<br>
>
> 테스트 코드 작성 전에 Repository 계층의 코드를 작성할 때는 주어진 입력을 받아서 데이터를 조회해주는 원시적인 역할만 수행함을 명확히 해야 한다. 그래야 Repository 계층의 테스트 경계가 명확해진다<br>
>
> 옛날에 Mybatis 사용시절에 과도하게 sql 을 조합해서 표현식을 만들어냈는데, 이런 경우 테스트를 하기가 점점 어려워진다. 이렇게 작성된 코드가 상용에 배포되면, 나중에 장애가 났을때 DB에서 어떤 조건값에서 에러가 났는지 찾기 어려워지는 순간이 찾아온다. <br>
>
> 그리고 `개발DB에서는 되는데 상용DB, QA DB에서는 안되는데?` 이런 이야기가 이곳 저곳에서 들려오는 아찔한 순간을 피하려면, DB에서는 가급적이면 데이터를 저장/수정/조회/삽입을 하는 데이터액세스 본연의 역할인 원자적인 역할만을 수행하도록 해줘야 한다.<br>
>
> 만약, 비즈니스 로직이나 비교, 체크 등의 요건을 구현해야 한다면 이런 내용들은 가급적 Service 계층에서 수행해야 한다. Service 계층은 Mockito, Stubbing, Fake 등을 통해서 가짜객체를 만들어서 여러 요건들을 여러 경우의 수를 두어서 Java 코드로 테스트케이스를 만들수 있기 때문에, 가급적 표현식, 체크 등의 기능들은 서비스 계층에서 수행하는 것이 안전하다.<br>

<br>

- Profile 을 통해 Datasource 를 주입받아서 테스트
- 주로 h2 로 먼저 테스트를 수행한다. 그리고 나서 개발 DB에서도 정상적인지를 테스트한다.
- 예전에는 mybatis 는 h2 테스트가 쉽지 않았는데, 요즘은 너무 오래된 mybatis 버전이 아닌 이상 h2 를 데이터소스로 지정해서 테스트하는 것이 가능해짐
- Repository 에서 예외를 발생시키거나 데이터를 변환하고 이런 작업을 하면 어떤 계층에서 예외가 발생했는지 찾기 어려워지는 현상이 발생한다.
- 이런 경우 Service 계층에 팩토리 메서드 또는 Mapper 클래스 등을 별도로 두어서 데이터 계층의 엔티티를 Service 계층에 전달하는 DTO 를 만드는 역할의 메서드들을 따로 구현해둔다.

<br>

