### 계층별 테스트

> <u>정리 중</u> 인 문서입니다. 시간이 부족한 불쌍한 개발자에요!!! 시간이 없어서 독백체로 정리되어 있습니다. 양해 부탁드려요 :)

<br>



각각의 기능의 경계를 명확하게 해두면 테스트 코드가 배포 전 동작 검증을 위한 하나의 수단이 될 수 있어서 좋다.<br>

가장 변경이 많이 되는 계층 → 변경사항이 다소 고정된 계층 순으로 계층을 나열해보면 아래와 같다.

- Controller → Service → Repository, DAO

<br>



### Controller

Controller 는 기획적인 면에서 OOORequest, OOOResponse 의 필드들이 변할 수 있어야 한다. 사업적인 면에 의해, 화면의 기획에 의해 가장 자주 많이 변경되는 곳이다. App, Web 과 맞닿아있는 endpoint 이기에 Swagger 나 RestDocs 같은 API 문서에 정의해둔 API 명세대로 Request, Response 가 이루어짐을 보장할 수 있는 테스트를 작성하는 것이 좋다. 예를 들면 아래의 테스트 코드들이 작성될 수 있다.

- 파라미터 바인딩, 파라미터 밸리데이션이 정확히 수행되는지를 보장하는 테스트 코드
- Exception 발생 시 미리 정해둔 각 Exception 에 대해 발생하는 예외코드, 예외메시지가 일치하는지를 보장하는 테스트 코드
- 특정 예외 발생시 Response Code가 올바르게 Response 로 전달되는지를 보장하는 테스트 코드



Controller 계층에서는 가급적 Service 계층의 비즈니스 논리보다는 예외코드, 파라미터 바인딩, 파라미터 밸리데이션, Response Code 에 관련된 코드 들만을 작성하는 것이 좋다. 그래야 Service 계층이 변경되어도 Controller 까지 변경해서 내부 로직의 flow 를 일일이 머릿속에 기억하고 있어야 하는 피곤함이 줄어든다.

Controller 계층에서 Service 계층에 어떤 파라미터를 주었을 때 어떤 값이 나올 것이라고 예측하는 코드는 자제해야 한다. Service 계층의 어떤 메서드가 어떤 파라미터에 대해서만 어떤 결괏값을 내는지를 알고 있어야 하기 때문이다.<br>

<br>



<u>정리중...</u>



### Service

<u>정리중...</u>



### Repository, DAO

<u>정리중...</u><br>



데이터를 Join 등을 통해 조회하고, 삽입/삭제/수정을 원자적으로 수행할 수 있어야 하고, 자주 변경될 여지가 가급적 적어야 하는 계층이다.<br>

Repository, DAO 의 쿼리 문에 자주 변경되는 코드를 작성하면 안된다. 가급적 자주 변경되는 내용은 Controller, Service 에서 비즈니스로직이나, Request, Response 모델로 명확하게 표현되야 한다. 예를 들어 Repository 에서는 가급적이면 Select Case 문을 통한 데이터 가공은 지양해야 한다. <br>

가끔은 Subquery 가 안티패턴이라는 이야기도 있지만, 필요하다면 써도 된다. 다만, 그 조회 연산이 추후 변경 가능성이 없고 확정된 기능이면 그대로 사용해도 될 것 같다.<br>

1년 전 쯤는 DAO 쪽 로직을 다루는 작업이 항상 "회사 제품"의 데이터를 다루는 것이라고 생각하고 신중하게 접근해야 한다고 생각했었는데, 지금 보면 조금 쑥스러운 생각인것 같기도 하다.

DB 계층의 테스트를 할 때는 아래의 테스트 코드들을 작성했던것 같다. 

- 



